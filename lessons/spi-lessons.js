/**
 * SPI Driver Lessons
 * Step-by-step guide to writing an SPI driver from scratch
 */

window.spiLessons = [
    // Step 1: Introduction to SPI
    {
        title: "Understanding SPI Protocol",
        content: `
            <h2>What is SPI?</h2>
            <p><strong>SPI</strong> (Serial Peripheral Interface) is a synchronous serial communication protocol used to communicate with sensors, displays, SD cards, and other peripherals. It's one of the most common communication protocols in embedded systems.</p>

            <h2>SPI Characteristics</h2>
            <ul>
                <li><strong>Synchronous</strong> - Uses a clock signal (no baud rate mismatch issues)</li>
                <li><strong>Full Duplex</strong> - Can send and receive simultaneously</li>
                <li><strong>Master-Slave</strong> - One master controls communication</li>
                <li><strong>High Speed</strong> - Can reach tens of MHz</li>
                <li><strong>4-Wire Interface</strong> - MOSI, MISO, SCK, NSS</li>
            </ul>

            <h2>SPI Signal Lines</h2>
            <table class="lesson-table">
                <tr>
                    <th>Signal</th>
                    <th>Name</th>
                    <th>Direction (Master)</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><code>MOSI</code></td>
                    <td>Master Out Slave In</td>
                    <td>Output</td>
                    <td>Data from master to slave</td>
                </tr>
                <tr>
                    <td><code>MISO</code></td>
                    <td>Master In Slave Out</td>
                    <td>Input</td>
                    <td>Data from slave to master</td>
                </tr>
                <tr>
                    <td><code>SCK</code></td>
                    <td>Serial Clock</td>
                    <td>Output</td>
                    <td>Clock signal generated by master</td>
                </tr>
                <tr>
                    <td><code>NSS/CS</code></td>
                    <td>Slave Select</td>
                    <td>Output</td>
                    <td>Selects which slave to communicate with</td>
                </tr>
            </table>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">SPI Connection Diagram</span>
                </div>
                <div class="code-content">
                    <pre><code>    MASTER                          SLAVE
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ        ‚îÇ
   ‚îÇ        ‚îÇ                     ‚îÇ        ‚îÇ
   ‚îÇ        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ        ‚îÇ
   ‚îÇ  STM32 ‚îÇ                     ‚îÇ Sensor ‚îÇ
   ‚îÇ        ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ        ‚îÇ
   ‚îÇ        ‚îÇ                     ‚îÇ        ‚îÇ
   ‚îÇ        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NSS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ        ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
                </div>
            </div>

            <div class="info-box note">
                <div class="info-box-title">üìò Key Concept</div>
                <p>In SPI, the master ALWAYS generates the clock. Even when receiving data, the master must send clock pulses. Data is sampled on clock edges.</p>
            </div>
        `
    },

    // Step 2: SPI Modes
    {
        title: "SPI Clock Modes (CPOL & CPHA)",
        content: `
            <h2>Understanding Clock Polarity and Phase</h2>
            <p>SPI has four modes determined by two parameters:</p>
            <ul>
                <li><strong>CPOL</strong> (Clock Polarity) - Idle state of clock line</li>
                <li><strong>CPHA</strong> (Clock Phase) - When data is sampled</li>
            </ul>

            <h2>The Four SPI Modes</h2>
            <table class="lesson-table">
                <tr>
                    <th>Mode</th>
                    <th>CPOL</th>
                    <th>CPHA</th>
                    <th>Clock Idle</th>
                    <th>Data Sampled</th>
                </tr>
                <tr>
                    <td>Mode 0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>Low</td>
                    <td>Rising edge</td>
                </tr>
                <tr>
                    <td>Mode 1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Low</td>
                    <td>Falling edge</td>
                </tr>
                <tr>
                    <td>Mode 2</td>
                    <td>1</td>
                    <td>0</td>
                    <td>High</td>
                    <td>Falling edge</td>
                </tr>
                <tr>
                    <td>Mode 3</td>
                    <td>1</td>
                    <td>1</td>
                    <td>High</td>
                    <td>Rising edge</td>
                </tr>
            </table>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">SPI Mode 0 (CPOL=0, CPHA=0) - Most Common</span>
                </div>
                <div class="code-content">
                    <pre><code>        ‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îê
   SCK  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ
        ‚Üë       ‚Üë       ‚Üë       ‚Üë
      Sample  Sample  Sample  Sample
        
   MOSI ‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê
          ‚îÇD7 ‚îÇD6 ‚îÇD5 ‚îÇD4 ‚îÇD3 ‚îÇD2 ‚îÇD1 ‚îÇD0
          
   NSS  ‚îÄ‚îÄ‚îÄ‚îê                           ‚îå‚îÄ‚îÄ‚îÄ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
                </div>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">‚ö†Ô∏è Important</div>
                <p>Always check your slave device's datasheet to determine which SPI mode it requires. Using the wrong mode will result in corrupted data!</p>
            </div>

            <h2>Bus Configurations</h2>
            <p>SPI can operate in different bus configurations:</p>
            <ul>
                <li><strong>Full Duplex</strong> - Uses both MOSI and MISO (most common)</li>
                <li><strong>Half Duplex</strong> - Bidirectional on single line</li>
                <li><strong>Simplex TX</strong> - Transmit only (no MISO needed)</li>
                <li><strong>Simplex RX</strong> - Receive only (no MOSI needed)</li>
            </ul>
        `
    },

    // Step 3: STM32 SPI Peripheral
    {
        title: "STM32F446RE SPI Peripheral",
        content: `
            <h2>SPI Instances on STM32F446RE</h2>
            <p>The STM32F446RE has four SPI peripherals:</p>

            <table class="lesson-table">
                <tr>
                    <th>SPI</th>
                    <th>Base Address</th>
                    <th>Bus</th>
                    <th>Max Speed</th>
                </tr>
                <tr>
                    <td>SPI1</td>
                    <td><code>0x4001 3000</code></td>
                    <td>APB2</td>
                    <td>45 MHz</td>
                </tr>
                <tr>
                    <td>SPI2</td>
                    <td><code>0x4000 3800</code></td>
                    <td>APB1</td>
                    <td>22.5 MHz</td>
                </tr>
                <tr>
                    <td>SPI3</td>
                    <td><code>0x4000 3C00</code></td>
                    <td>APB1</td>
                    <td>22.5 MHz</td>
                </tr>
                <tr>
                    <td>SPI4</td>
                    <td><code>0x4001 3400</code></td>
                    <td>APB2</td>
                    <td>45 MHz</td>
                </tr>
            </table>

            <h2>SPI Pin Mapping (Common Pins)</h2>
            <table class="lesson-table">
                <tr>
                    <th>SPI2</th>
                    <th>Pin</th>
                    <th>Alternate Function</th>
                </tr>
                <tr>
                    <td>SCK</td>
                    <td>PB13</td>
                    <td>AF5</td>
                </tr>
                <tr>
                    <td>MISO</td>
                    <td>PB14</td>
                    <td>AF5</td>
                </tr>
                <tr>
                    <td>MOSI</td>
                    <td>PB15</td>
                    <td>AF5</td>
                </tr>
                <tr>
                    <td>NSS</td>
                    <td>PB12</td>
                    <td>AF5</td>
                </tr>
            </table>

            <h2>SPI Register Map</h2>
            <table class="lesson-table">
                <tr>
                    <th>Register</th>
                    <th>Offset</th>
                    <th>Purpose</th>
                </tr>
                <tr>
                    <td><code>CR1</code></td>
                    <td>0x00</td>
                    <td>Control Register 1 - Main configuration</td>
                </tr>
                <tr>
                    <td><code>CR2</code></td>
                    <td>0x04</td>
                    <td>Control Register 2 - DMA/Interrupt config</td>
                </tr>
                <tr>
                    <td><code>SR</code></td>
                    <td>0x08</td>
                    <td>Status Register - Flags</td>
                </tr>
                <tr>
                    <td><code>DR</code></td>
                    <td>0x0C</td>
                    <td>Data Register - TX/RX buffer</td>
                </tr>
                <tr>
                    <td><code>CRCPR</code></td>
                    <td>0x10</td>
                    <td>CRC Polynomial Register</td>
                </tr>
                <tr>
                    <td><code>RXCRCR</code></td>
                    <td>0x14</td>
                    <td>RX CRC Register</td>
                </tr>
                <tr>
                    <td><code>TXCRCR</code></td>
                    <td>0x18</td>
                    <td>TX CRC Register</td>
                </tr>
            </table>

            <div class="info-box tip">
                <div class="info-box-title">üí° Bus Speed Matters</div>
                <p>SPI1 and SPI4 are on APB2 (faster bus), while SPI2 and SPI3 are on APB1 (slower bus). Choose your SPI peripheral based on speed requirements!</p>
            </div>
        `
    },

    // Step 4: Creating SPI Header File
    {
        title: "Creating the SPI Driver Header",
        content: `
            <h2>Configuration Structure</h2>
            <p>The SPI configuration structure holds all settings needed to configure the peripheral:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.h</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="preprocessor">#ifndef</span> INC_STM32F446XX_SPI_DRIVER_H_
<span class="preprocessor">#define</span> INC_STM32F446XX_SPI_DRIVER_H_

<span class="preprocessor">#include</span> <span class="string">"stm32f446xx.h"</span>

<span class="comment">/*
 * Configuration structure for SPIx peripheral
 */</span>
<span class="keyword">typedef struct</span>
{
    <span class="type">uint8_t</span> SPI_DeviceMode;    <span class="comment">// Master or Slave</span>
    <span class="type">uint8_t</span> SPI_BusConfig;     <span class="comment">// Full-duplex, half-duplex, simplex</span>
    <span class="type">uint8_t</span> SPI_SclkSpeed;     <span class="comment">// Clock speed (prescaler)</span>
    <span class="type">uint8_t</span> SPI_DFF;           <span class="comment">// Data frame format (8 or 16 bit)</span>
    <span class="type">uint8_t</span> SPI_CPOL;          <span class="comment">// Clock polarity</span>
    <span class="type">uint8_t</span> SPI_CPHA;          <span class="comment">// Clock phase</span>
    <span class="type">uint8_t</span> SPI_SSM;           <span class="comment">// Software slave management</span>
} <span class="type">SPI_Config_t</span>;</code></pre>
                </div>
            </div>

            <h2>Handle Structure</h2>
            <p>The handle includes the peripheral pointer, configuration, and runtime state for interrupts:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.h</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="comment">/*
 * Handle structure for SPIx peripheral
 */</span>
<span class="keyword">typedef struct</span>
{
    <span class="type">SPI_RegDef_t</span>  *pSPIx;       <span class="comment">// Pointer to SPI peripheral</span>
    <span class="type">SPI_Config_t</span>  SPIConfig;   <span class="comment">// Configuration settings</span>
    
    <span class="comment">// For interrupt-based communication</span>
    <span class="type">uint8_t</span>       *pTxBuffer;   <span class="comment">// TX buffer pointer</span>
    <span class="type">uint8_t</span>       *pRxBuffer;   <span class="comment">// RX buffer pointer</span>
    <span class="type">uint32_t</span>      TxLen;        <span class="comment">// TX length</span>
    <span class="type">uint32_t</span>      RxLen;        <span class="comment">// RX length</span>
    <span class="type">uint8_t</span>       TxState;      <span class="comment">// TX state</span>
    <span class="type">uint8_t</span>       RxState;      <span class="comment">// RX state</span>
} <span class="type">SPI_Handle_t</span>;</code></pre>
                </div>
            </div>

            <h2>Configuration Macros</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.h</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="comment">/*
 * @SPI_DeviceMode
 */</span>
<span class="preprocessor">#define</span> SPI_DEVICE_MODE_MASTER    <span class="number">1</span>
<span class="preprocessor">#define</span> SPI_DEVICE_MODE_SLAVE     <span class="number">0</span>

<span class="comment">/*
 * @SPI_BusConfig
 */</span>
<span class="preprocessor">#define</span> SPI_BUS_CONFIG_FD         <span class="number">1</span>  <span class="comment">// Full duplex</span>
<span class="preprocessor">#define</span> SPI_BUS_CONFIG_HD         <span class="number">2</span>  <span class="comment">// Half duplex</span>
<span class="preprocessor">#define</span> SPI_BUS_CONFIG_SIMPLEX_RX <span class="number">3</span>  <span class="comment">// Simplex RX only</span>

<span class="comment">/*
 * @SPI_SclkSpeed - Prescaler values
 */</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV2       <span class="number">0</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV4       <span class="number">1</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV8       <span class="number">2</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV16      <span class="number">3</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV32      <span class="number">4</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV64      <span class="number">5</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV128     <span class="number">6</span>
<span class="preprocessor">#define</span> SPI_SCLK_SPEED_DIV256     <span class="number">7</span>

<span class="comment">/*
 * @SPI_DFF - Data Frame Format
 */</span>
<span class="preprocessor">#define</span> SPI_DFF_8BITS             <span class="number">0</span>
<span class="preprocessor">#define</span> SPI_DFF_16BITS            <span class="number">1</span>

<span class="comment">/*
 * @SPI_CPOL
 */</span>
<span class="preprocessor">#define</span> SPI_CPOL_LOW              <span class="number">0</span>
<span class="preprocessor">#define</span> SPI_CPOL_HIGH             <span class="number">1</span>

<span class="comment">/*
 * @SPI_CPHA
 */</span>
<span class="preprocessor">#define</span> SPI_CPHA_LOW              <span class="number">0</span>  <span class="comment">// First clock edge</span>
<span class="preprocessor">#define</span> SPI_CPHA_HIGH             <span class="number">1</span>  <span class="comment">// Second clock edge</span>

<span class="comment">/*
 * @SPI_SSM - Software Slave Management
 */</span>
<span class="preprocessor">#define</span> SPI_SSM_DI                <span class="number">0</span>  <span class="comment">// Hardware NSS</span>
<span class="preprocessor">#define</span> SPI_SSM_EN                <span class="number">1</span>  <span class="comment">// Software NSS</span></code></pre>
                </div>
            </div>

            <div class="info-box note">
                <div class="info-box-title">üìò Software vs Hardware NSS</div>
                <p>With <strong>SSM=1</strong> (software), you control the slave select manually. With <strong>SSM=0</strong> (hardware), the SPI peripheral controls NSS automatically.</p>
            </div>
        `
    },

    // Step 5: SPI API Functions
    {
        title: "SPI API Function Prototypes",
        content: `
            <h2>Complete API Declaration</h2>
            <p>Here are all the functions our SPI driver will provide:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.h</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="comment">/*************************************************************
 *                 APIs supported by this driver
 *************************************************************/</span>

<span class="comment">/*
 * Peripheral Clock Setup
 */</span>
<span class="type">void</span> <span class="function">SPI_PeriClockControl</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi);

<span class="comment">/*
 * Init and De-init
 */</span>
<span class="type">void</span> <span class="function">SPI_Init</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle);
<span class="type">void</span> <span class="function">SPI_DeInit</span>(<span class="type">SPI_RegDef_t</span> *pSPIx);

<span class="comment">/*
 * Data Send and Receive (Blocking/Polling)
 */</span>
<span class="type">void</span> <span class="function">SPI_SendData</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> *pTxBuffer, <span class="type">uint32_t</span> Len);
<span class="type">void</span> <span class="function">SPI_ReceiveData</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> *pRxBuffer, <span class="type">uint32_t</span> Len);

<span class="comment">/*
 * Data Send and Receive (Interrupt-based)
 */</span>
<span class="type">uint8_t</span> <span class="function">SPI_SendDataIT</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle, <span class="type">uint8_t</span> *pTxBuffer, <span class="type">uint32_t</span> Len);
<span class="type">uint8_t</span> <span class="function">SPI_ReceiveDataIT</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle, <span class="type">uint8_t</span> *pRxBuffer, <span class="type">uint32_t</span> Len);

<span class="comment">/*
 * IRQ Configuration and ISR Handling
 */</span>
<span class="type">void</span> <span class="function">SPI_IRQInterruptConfig</span>(<span class="type">uint8_t</span> IRQNumber, <span class="type">uint8_t</span> EnorDi);
<span class="type">void</span> <span class="function">SPI_IRQPriorityConfig</span>(<span class="type">uint8_t</span> IRQNumber, <span class="type">uint32_t</span> IRQPriority);
<span class="type">void</span> <span class="function">SPI_IRQHandling</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle);

<span class="comment">/*
 * Other Peripheral Control APIs
 */</span>
<span class="type">void</span> <span class="function">SPI_PeripheralControl</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi);
<span class="type">void</span> <span class="function">SPI_SSIConfig</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi);
<span class="type">void</span> <span class="function">SPI_SSOEConfig</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi);
<span class="type">uint8_t</span> <span class="function">SPI_GetFlagStatus</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint32_t</span> FlagName);
<span class="type">void</span> <span class="function">SPI_ClearOVRFlag</span>(<span class="type">SPI_RegDef_t</span> *pSPIx);
<span class="type">void</span> <span class="function">SPI_CloseTransmission</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle);
<span class="type">void</span> <span class="function">SPI_CloseReception</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle);

<span class="comment">/*
 * Application Callback (weak function to be overridden)
 */</span>
<span class="type">void</span> <span class="function">SPI_ApplicationEventCallback</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle, <span class="type">uint8_t</span> AppEvent);</code></pre>
                </div>
            </div>

            <h2>Status Flags</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.h</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="comment">/*
 * SPI Status Register Flags
 */</span>
<span class="preprocessor">#define</span> SPI_RXNE_FLAG    (<span class="number">1</span> << <span class="number">0</span>)  <span class="comment">// RX buffer not empty</span>
<span class="preprocessor">#define</span> SPI_TXE_FLAG     (<span class="number">1</span> << <span class="number">1</span>)  <span class="comment">// TX buffer empty</span>
<span class="preprocessor">#define</span> SPI_CHSIDE_FLAG  (<span class="number">1</span> << <span class="number">2</span>)  <span class="comment">// Channel side</span>
<span class="preprocessor">#define</span> SPI_UDR_FLAG     (<span class="number">1</span> << <span class="number">3</span>)  <span class="comment">// Underrun flag</span>
<span class="preprocessor">#define</span> SPI_CRCERR_FLAG  (<span class="number">1</span> << <span class="number">4</span>)  <span class="comment">// CRC error</span>
<span class="preprocessor">#define</span> SPI_MODF_FLAG    (<span class="number">1</span> << <span class="number">5</span>)  <span class="comment">// Mode fault</span>
<span class="preprocessor">#define</span> SPI_OVR_FLAG     (<span class="number">1</span> << <span class="number">6</span>)  <span class="comment">// Overrun flag</span>
<span class="preprocessor">#define</span> SPI_BSY_FLAG     (<span class="number">1</span> << <span class="number">7</span>)  <span class="comment">// Busy flag</span>
<span class="preprocessor">#define</span> SPI_FRE_FLAG     (<span class="number">1</span> << <span class="number">8</span>)  <span class="comment">// Frame error</span></code></pre>
                </div>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">üí° Blocking vs Interrupt</div>
                <p><strong>Blocking (Polling)</strong>: CPU waits until transfer complete. Simple but wastes CPU cycles.<br>
                <strong>Interrupt-based</strong>: CPU is free during transfer. More complex but efficient.</p>
            </div>
        `
    },

    // Step 6: Implementing SPI Init
    {
        title: "Implementing SPI Initialization",
        content: `
            <h2>Understanding SPI_CR1 Register</h2>
            <p>The Control Register 1 (CR1) contains most configuration bits:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">SPI_CR1 Bit Map</span>
                </div>
                <div class="code-content">
                    <pre><code>Bit 15: BIDIMODE - Bidirectional data mode
Bit 14: BIDIOE   - Output enable in bidirectional mode
Bit 13: CRCEN    - Hardware CRC calculation enable
Bit 12: CRCNEXT  - CRC transfer next
Bit 11: DFF      - Data frame format (0=8bit, 1=16bit)
Bit 10: RXONLY   - Receive only mode
Bit 9:  SSM      - Software slave management
Bit 8:  SSI      - Internal slave select
Bit 7:  LSBFIRST - Frame format (0=MSB first)
Bit 6:  SPE      - SPI enable
Bit 5:3: BR[2:0] - Baud rate control (prescaler)
Bit 2:  MSTR     - Master selection
Bit 1:  CPOL     - Clock polarity
Bit 0:  CPHA     - Clock phase</code></pre>
                </div>
            </div>

            <h2>SPI_Init Implementation</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.c</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="type">void</span> <span class="function">SPI_Init</span>(<span class="type">SPI_Handle_t</span> *pSPIHandle)
{
    <span class="comment">// Enable peripheral clock first!</span>
    SPI_PeriClockControl(pSPIHandle->pSPIx, ENABLE);
    
    <span class="type">uint32_t</span> tempreg = <span class="number">0</span>;

    <span class="comment">// 1. Configure device mode (Master/Slave)</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_DeviceMode << <span class="number">2</span>);

    <span class="comment">// 2. Configure bus config</span>
    <span class="keyword">if</span> (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD)
    {
        <span class="comment">// Full duplex: BIDIMODE = 0</span>
        tempreg &= ~(<span class="number">1</span> << <span class="number">15</span>);
    }
    <span class="keyword">else if</span> (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD)
    {
        <span class="comment">// Half duplex: BIDIMODE = 1</span>
        tempreg |= (<span class="number">1</span> << <span class="number">15</span>);
    }
    <span class="keyword">else if</span> (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RX)
    {
        <span class="comment">// Simplex RX: BIDIMODE = 0, RXONLY = 1</span>
        tempreg &= ~(<span class="number">1</span> << <span class="number">15</span>);
        tempreg |= (<span class="number">1</span> << <span class="number">10</span>);
    }

    <span class="comment">// 3. Configure clock speed (baud rate)</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_SclkSpeed << <span class="number">3</span>);

    <span class="comment">// 4. Configure DFF (data frame format)</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_DFF << <span class="number">11</span>);

    <span class="comment">// 5. Configure CPOL</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_CPOL << <span class="number">1</span>);

    <span class="comment">// 6. Configure CPHA</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_CPHA << <span class="number">0</span>);

    <span class="comment">// 7. Configure SSM</span>
    tempreg |= (pSPIHandle->SPIConfig.SPI_SSM << <span class="number">9</span>);

    <span class="comment">// Write to CR1 register</span>
    pSPIHandle->pSPIx->CR1 = tempreg;
}</code></pre>
                </div>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">‚ö†Ô∏è Don't Forget!</div>
                <p>SPI_Init() only configures the peripheral. You must call <code>SPI_PeripheralControl(SPIx, ENABLE)</code> to actually enable SPI before transmitting!</p>
            </div>
        `
    },

    // Step 7: Send and Receive
    {
        title: "Implementing Send and Receive",
        content: `
            <h2>Blocking Send Function</h2>
            <p>This function waits until all data is transmitted:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.c</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="type">void</span> <span class="function">SPI_SendData</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> *pTxBuffer, <span class="type">uint32_t</span> Len)
{
    <span class="keyword">while</span> (Len > <span class="number">0</span>)
    {
        <span class="comment">// 1. Wait until TXE is set (TX buffer empty)</span>
        <span class="keyword">while</span> (!(pSPIx->SR & SPI_TXE_FLAG));

        <span class="comment">// 2. Check DFF bit in CR1</span>
        <span class="keyword">if</span> (pSPIx->CR1 & (<span class="number">1</span> << <span class="number">11</span>))
        {
            <span class="comment">// 16-bit DFF</span>
            pSPIx->DR = *((<span class="type">uint16_t</span>*)pTxBuffer);
            Len -= <span class="number">2</span>;
            (<span class="type">uint16_t</span>*)pTxBuffer++;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// 8-bit DFF</span>
            pSPIx->DR = *pTxBuffer;
            Len--;
            pTxBuffer++;
        }
    }
}</code></pre>
                </div>
            </div>

            <h2>Blocking Receive Function</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.c</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="type">void</span> <span class="function">SPI_ReceiveData</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> *pRxBuffer, <span class="type">uint32_t</span> Len)
{
    <span class="keyword">while</span> (Len > <span class="number">0</span>)
    {
        <span class="comment">// 1. Wait until RXNE is set (RX buffer not empty)</span>
        <span class="keyword">while</span> (!(pSPIx->SR & SPI_RXNE_FLAG));

        <span class="comment">// 2. Check DFF bit in CR1</span>
        <span class="keyword">if</span> (pSPIx->CR1 & (<span class="number">1</span> << <span class="number">11</span>))
        {
            <span class="comment">// 16-bit DFF</span>
            *((<span class="type">uint16_t</span>*)pRxBuffer) = pSPIx->DR;
            Len -= <span class="number">2</span>;
            (<span class="type">uint16_t</span>*)pRxBuffer++;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// 8-bit DFF</span>
            *pRxBuffer = pSPIx->DR;
            Len--;
            pRxBuffer++;
        }
    }
}</code></pre>
                </div>
            </div>

            <h2>Helper Functions</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">stm32f446xx_spi_driver.c</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="comment">// Get flag status from SR register</span>
<span class="type">uint8_t</span> <span class="function">SPI_GetFlagStatus</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint32_t</span> FlagName)
{
    <span class="keyword">if</span> (pSPIx->SR & FlagName)
    {
        <span class="keyword">return</span> FLAG_SET;
    }
    <span class="keyword">return</span> FLAG_RESET;
}

<span class="comment">// Enable/Disable SPI peripheral</span>
<span class="type">void</span> <span class="function">SPI_PeripheralControl</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi)
{
    <span class="keyword">if</span> (EnorDi == ENABLE)
    {
        pSPIx->CR1 |= (<span class="number">1</span> << <span class="number">6</span>);  <span class="comment">// Set SPE bit</span>
    }
    <span class="keyword">else</span>
    {
        pSPIx->CR1 &= ~(<span class="number">1</span> << <span class="number">6</span>); <span class="comment">// Clear SPE bit</span>
    }
}

<span class="comment">// Configure SSI bit (for software slave management)</span>
<span class="type">void</span> <span class="function">SPI_SSIConfig</span>(<span class="type">SPI_RegDef_t</span> *pSPIx, <span class="type">uint8_t</span> EnorDi)
{
    <span class="keyword">if</span> (EnorDi == ENABLE)
    {
        pSPIx->CR1 |= (<span class="number">1</span> << <span class="number">8</span>);
    }
    <span class="keyword">else</span>
    {
        pSPIx->CR1 &= ~(<span class="number">1</span> << <span class="number">8</span>);
    }
}</code></pre>
                </div>
            </div>

            <div class="info-box important">
                <div class="info-box-title">üö® MODF Error</div>
                <p>If using software slave management (SSM=1) as master, you MUST set SSI=1 to keep NSS high internally. Otherwise you'll get a Mode Fault (MODF) error!</p>
            </div>
        `
    },

    // Step 8: Testing SPI
    {
        title: "Testing Your SPI Driver",
        content: `
            <h2>Test Application: SPI Loopback</h2>
            <p>First, let's test with a simple loopback - connect MOSI to MISO on the same MCU:</p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-filename">spi_test.c</span>
                    <button class="copy-btn">Copy</button>
                </div>
                <div class="code-content">
                    <pre><code><span class="preprocessor">#include</span> <span class="string">"stm32f446xx_gpio_driver.h"</span>
<span class="preprocessor">#include</span> <span class="string">"stm32f446xx_spi_driver.h"</span>
<span class="preprocessor">#include</span> <span class="string">&lt;string.h&gt;</span>

<span class="comment">/*
 * SPI2 Pins:
 * PB12 - NSS
 * PB13 - SCK
 * PB14 - MISO
 * PB15 - MOSI
 * Alternate Function: AF5
 */</span>

<span class="type">void</span> <span class="function">SPI2_GPIOInit</span>(<span class="type">void</span>)
{
    <span class="type">GPIO_Handle_t</span> SPIPins;

    SPIPins.pGPIOx = GPIOB;
    SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = <span class="number">5</span>;
    SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

    GPIO_PeriClockControl(GPIOB, ENABLE);

    <span class="comment">// SCK</span>
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
    GPIO_Init(&SPIPins);

    <span class="comment">// MOSI</span>
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
    GPIO_Init(&SPIPins);

    <span class="comment">// MISO</span>
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
    GPIO_Init(&SPIPins);
}

<span class="type">void</span> <span class="function">SPI2_Init</span>(<span class="type">void</span>)
{
    <span class="type">SPI_Handle_t</span> SPI2Handle;

    SPI2Handle.pSPIx = SPI2;
    SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
    SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
    SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV8;
    SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
    SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
    SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
    SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_EN;  <span class="comment">// Software slave mgmt</span>

    SPI_Init(&SPI2Handle);
}

<span class="type">int</span> <span class="function">main</span>(<span class="type">void</span>)
{
    <span class="type">char</span> data[] = <span class="string">"Hello SPI!"</span>;

    <span class="comment">// Initialize GPIO pins for SPI2</span>
    SPI2_GPIOInit();

    <span class="comment">// Initialize SPI2 peripheral</span>
    SPI2_Init();

    <span class="comment">// Set SSI to avoid MODF error</span>
    SPI_SSIConfig(SPI2, ENABLE);

    <span class="comment">// Enable SPI2 peripheral</span>
    SPI_PeripheralControl(SPI2, ENABLE);

    <span class="comment">// Send data</span>
    SPI_SendData(SPI2, (<span class="type">uint8_t</span>*)data, strlen(data));

    <span class="comment">// Wait for SPI to complete</span>
    <span class="keyword">while</span> (SPI_GetFlagStatus(SPI2, SPI_BSY_FLAG));

    <span class="comment">// Disable SPI</span>
    SPI_PeripheralControl(SPI2, DISABLE);

    <span class="keyword">while</span> (<span class="number">1</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                </div>
            </div>

            <h2>Debugging Tips</h2>
            <div class="info-box tip">
                <div class="info-box-title">üí° Common Issues</div>
                <ul>
                    <li><strong>No clock on SCK:</strong> Check GPIO alternate function and SPI clock enable</li>
                    <li><strong>MODF error:</strong> Set SSI=1 when using software NSS management</li>
                    <li><strong>TXE never sets:</strong> SPI might not be enabled (SPE bit)</li>
                    <li><strong>Wrong data:</strong> Check CPOL/CPHA settings match your slave device</li>
                </ul>
            </div>

            <h2>Using Logic Analyzer</h2>
            <p>Connect a logic analyzer to SCK and MOSI pins to verify:</p>
            <ul>
                <li>Clock frequency matches expected (APB_CLK / prescaler)</li>
                <li>Data appears on MOSI during clock pulses</li>
                <li>CPOL/CPHA settings are correct</li>
            </ul>

            <h2>üéâ Congratulations!</h2>
            <p>You've built a working SPI driver! You now understand:</p>
            <ul>
                <li>SPI protocol fundamentals</li>
                <li>How to configure SPI registers</li>
                <li>Blocking send/receive operations</li>
                <li>GPIO alternate function setup for SPI</li>
            </ul>
        `
    }
];

